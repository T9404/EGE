############### 1ый Метод ##################

f = open('27_B.txt')
n = int(f.readline())


# https://youtu.be/wtcM3-0A4XQ Внимательно посмотреть 

s, max_s, max_l = 0, 0, 0 # максимальная сумма
min_ps = [float('inf')]*43 # кратна 43, ищем суммы с разн остатками
min_pl  = [0] * 43 # длины сумм из min_ps

for i in range(n): #индексация с нуля
    x = int(f.readline()) #считали число


    s+=x #прибавили к общей сумме
    ost = s % 43 # узнали остаток новой суммы

    
    if ost == 0: # она всегда будет больше пред, т.к. непрерывно прибавляется число Х
        max_s, max_l = s, i+1 # сумма максимальна, индексация с нуля, поэтому +1

        
    else:
        if min_ps[ost] != float('inf'): #если сумма уже есть, т.е. мы ее заносили в массив, берем эти суммы в  if s < min_ps[ost]:  
            m = s - min_ps[ost] # s % 43 - min_ps[s % 43] == 0 всегда, подробнее по ссылке на стрим
            l = i + 1 - min_pl[ost] # не забываем про индексацию

            if (m > max_s) or (m == max_s and l < max_l): #если последовательностей неск, укажите...
                max_s, max_l = m, l  # у этой суммы % 43 == 0 всегда


                
    if s < min_ps[ost]:  # float('inf') - питонская бесконечность
        min_ps[ost], min_pl[ost] = s, i+1  #уменьшаем сумму(массив!!!)

        
print(max_l) #требуют длину, а мы послушные 


############### 2ой Метод #####################

f = open('27_B.txt')
n = int(f.readline())

curr_s = [0]*43 #динамический счет сумм по остаткам
curr_l = [0]*43

max_sum, min_len = 0, 0 #итоговые значения
for _ in range(n):
    x = int(f.readline())

    s = [0]*43 #новый массив, который включает новое число и все пары нового числа+ значения из curr_s
    l = [0]*43

    for i in range(43):
        if curr_s[i] != 0:
            a = curr_s[i] + x #все пары
            if a > s[a % 43]:
                s[a % 43] = a
                l[a % 43] = curr_l[i] + 1 #идексация

    if x > s[x % 43]: # включает новое число
        s[x % 43] = x; l[x % 43] = 1 

    if s[0] > max_sum or (s[0] == max_sum and l[0] < min_len): #читайте внимательно задание
        max_sum, min_len = s[0], l[0]
    

    curr_s = s; curr_l = l; #обновление всех сумм с разными остатками
    
    
print(min_len)



################## 3ий Метод #############################


f = open('27-75a.txt')
n = int(f.readline())

s = [ [ 0, 0] ]
max_sum, min_len = 0, 0

for i in range(n):
    
    x = int(f.readline())

    cmb = [ [a+x, b+1] for a, b in s ] + [ [x, 1] ] #в cmb хранятся: 1) новые пары от s с числом; 2) новое число
    # a - сумма, b - длина
    
    s = {x[0] % 43: x for x in sorted(cmb)} #сортировка по остатку суммы на 43, x - массив
    
    #МЫ имеем пример: 21:[21, 1], 0:[43, 3] , ключ- остаток от деления, значение - массив с длин и сумм

    
    if 0 in s: #если КЛЮЧ равен 0, т.е. делится
        a, b = s[0] #распаковка массива с длиной и суммой, кратной 43

        if a > max_sum or a == max_sum and b < min_len: #стандартная проверка
            max_sum = a
            min_len = b

    s = s.values() #values() выдает нам коллекцию наших массивов в словаре(без ключей)
    #например: {'hello':[5, 1], 'imfine': [12, 3]} values вернет [5, 1] и [12, 3]  

print(min_len)
